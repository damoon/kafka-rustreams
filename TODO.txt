* memory Driver
* flush data pipeline

* verify logged topic in memory for unit tests

* partitions within topics

* tilt
* kafka operator
* kafka Driver

* log levels
* limit number of CPUs / autodetect cgroup limit https://www.youtube.com/watch?v=2WXNY1ppTzY

* transactional copy
* drain and flush periodically to stay, including commit, within 100ms

* postgresql Driver
* file Driver
* git Driver

* deser json, avro, and protobuf

* clean shutdown [https://docs.rs/tokio/1.1.0/tokio/signal/index.html]
* generate graphviz dot output [https://stackoverflow.com/questions/38088067/equivalent-of-func-or-function-in-rust]
* ensure librdkafka and kafka streams java client use the same hash function for partitioning

* stateless operations [https://kafka.apache.org/27/documentation/streams/developer-guide/dsl-api.html#stateless-transformations]
* statefull operations [https://kafka.apache.org/27/documentation/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl-transformations-stateful]
* Processors [https://kafka.apache.org/27/documentation/streams/developer-guide/processor-api.html]

* configure tokio to run the number of workers that fit the the cgroup cpu limit [https://blog.logrocket.com/a-practical-guide-to-async-in-rust/] [https://blog.logrocket.com/asynchronous-i-o-and-async-await-packages-in-rust/]
* views accessable via http [https://github.com/jonhoo/left-right]
* /metrics endpoint
* /health endpoint
* debug ui: select offset to load

* tune with https://nnethercote.github.io/perf-book/build-configuration.html
